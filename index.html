<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>평행사변형 네 각의 합 = 360° (확장판)</title>
<style>
  :root {
    --bg: #f7fafc; --ink: #0f172a; --muted: #475569; --line: #e2e8f0; --accent: #2563eb; --cut: #ef4444;
  }
  html, body { height: 100%; margin: 0; font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Helvetica, Arial, Apple SD Gothic Neo, "나눔고딕", sans-serif; color: var(--ink); background: var(--bg); }
  .wrap { max-width: 1100px; margin: 20px auto; padding: 12px; }
  .toolbar { position: relative; display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
  .hint { font-size: 13px; color: var(--muted); }
  .panel { display: grid; grid-template-columns: 1fr 320px; gap: 12px; }
  .card { background: white; border: 1px solid var(--line); border-radius: 16px; box-shadow: 0 2px 4px rgb(0 0 0 / 7%); }
  .view { height: 560px; }
  .side { padding: 12px 14px; font-size: 14px; }
  .side h3 { margin: 8px 0 6px; font-size: 15px; }
  .legend { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
  .pill { display: flex; align-items: center; justify-content: space-between; border: 1px solid var(--line); border-radius: 12px; padding: 6px 10px; }
  .grid line { stroke: #e5e7eb; }
  .handle { cursor: pointer; }
  .grab { cursor: grab; }
  .grabbing { cursor: grabbing !important; }
  .mode-cut .cut-cursor { cursor: crosshair; }
  .top-right { position: absolute; right: 0; top: 0; display: flex; gap: 8px; }
  .icon { width: 40px; height: 40px; display: inline-flex; align-items: center; justify-content: center; border: 1px solid var(--line); border-radius: 12px; background: white; box-shadow: 0 1px 2px rgb(0 0 0 / 8%); font-size: 18px; }
  .icon.active { outline: 2px solid var(--accent); }
  .badge { font-size: 12px; color: #334155; background: #eef2ff; border: 1px solid #c7d2fe; padding: 2px 6px; border-radius: 999px; }
  .colors { display: none; grid-template-columns: 1fr 1fr; gap: 6px; }
  .colors label { display:flex; align-items:center; justify-content:space-between; gap:8px; border:1px solid var(--line); border-radius:12px; padding:6px 10px; }
  .colors input[type="color"] { width: 44px; height: 28px; padding: 0; border: none; background: transparent; }
  .sep { height: 1px; background: var(--line); margin: 10px 0; }
</style>
</head>
<body>
<div class="wrap">
  <div class="toolbar">
    <div class="hint">점 A, B, C, D를 드래그하면 <b>항상 평행사변형</b>이 되도록 반대쪽 점이 자동으로 맞춰집니다.</div>
    <div class="top-right">
      <button id="btnCut" class="icon" title="자르기(Scissors)">
        <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="6" cy="6" r="3"></circle>
          <circle cx="6" cy="18" r="3"></circle>
          <path d="M20 4 L8.5 15.5"></path>
          <path d="M8.5 8.5 L20 20"></path>
        </svg>
      </button>
      <button id="btnReset" class="icon" title="초기화" aria-label="초기화">⟲</button>
    </div>
  </div>

  <div class="panel">
    <div class="card view" id="stageWrap"></div>
    <div class="card side">
      <h3>각도</h3>
      <div class="legend" id="legend"></div>
      <div style="margin-top:8px; padding:8px; background:#f8fafc; border:1px solid var(--line); border-radius:12px;">
        ∠A + ∠B + ∠C + ∠D = <b id="sum">360°</b>
        <div class="hint">(소수 반올림으로 360°에서 ±0.1° 오차가 보일 수 있어요)</div>
      </div>
      <div class="sep"></div>
      <h3>조각 색상</h3>
      <div id="colorControls" class="colors">
        <label>
          <span>조각 1</span>
          <input id="color1" type="color" value="#c7d2fe" />
        </label>
        <label>
          <span>조각 2</span>
          <input id="color2" type="color" value="#fde68a" />
        </label>
      </div>
      <div class="sep"></div>
      <h3>활용 팁</h3>
      <ol class="hint" style="margin:0 0 6px 18px; line-height:1.5;">
        <li>가위 아이콘을 눌러 선분을 그리면 도형을 <b>두 조각</b>으로 자릅니다.</li>
        <li>잘린 조각을 각각 드래그해 <b>서로 반대 방향</b>으로 붙이면 <span class="badge">180° + 180° = 360°</span>를 관찰할 수 있어요.</li>
      </ol>
    </div>
  </div>
</div>

<svg id="stage" viewBox="0 0 960 560" width="100%" height="100%" class="card" style="display:none"></svg>

<script>
(function(){
  const W = 960, H = 560;
  const stageWrap = document.getElementById('stageWrap');
  const svg = document.getElementById('stage'); stageWrap.appendChild(svg); svg.style.display='block';

  let mode = 'shape'; // 'shape' | 'cut' | 'pieces'
  const btnCut = document.getElementById('btnCut');
  const btnReset = document.getElementById('btnReset');

  let A = {x: 220, y: 200}; let B = {x: 420, y: 180}; let C = {x: 560, y: 320}; let D = {x: 360, y: 340};
  let pieces = null; // [{pts, dx, dy, color}, {…}]

  // grid
  const grid = mk('g', {class:'grid'});
  for (let x=0; x<=W; x+=40) grid.appendChild(mk('line', {x1:x,y1:0,x2:x,y2:H,stroke:'#e5e7eb'}));
  for (let y=0; y<=H; y+=40) grid.appendChild(mk('line', {x1:0,y1:y,x2:W,y2:y,stroke:'#e5e7eb'}));
  svg.appendChild(grid);

  const layerPoly = mk('g'); svg.appendChild(layerPoly);
  const layerCut = mk('g'); svg.appendChild(layerCut);
  const layerHandles = mk('g'); svg.appendChild(layerHandles);

  const legend = document.getElementById('legend');
  const sumEl = document.getElementById('sum');
  const colorControls = document.getElementById('colorControls');
  const color1El = document.getElementById('color1');
  const color2El = document.getElementById('color2');

  function mk(tag, attrs={}){ const el=document.createElementNS('http://www.w3.org/2000/svg', tag); for(const k in attrs) el.setAttribute(k, attrs[k]); return el; }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function norm(v){ const m=Math.hypot(v.x,v.y)||1; return {x:v.x/m,y:v.y/m}; }

  function angleAt(pts, i){
    const n=pts.length; const p=pts[(i-1+n)%n], q=pts[i], r=pts[(i+1)%n];
    const v1={x:p.x-q.x,y:p.y-q.y}, v2={x:r.x-q.x,y:r.y-q.y};
    const dot=v1.x*v2.x+v1.y*v2.y; const m1=Math.hypot(v1.x,v1.y), m2=Math.hypot(v2.x,v2.y);
    if(!m1||!m2) return 0; let cos=clamp(dot/(m1*m2),-1,1); return Math.acos(cos)*180/Math.PI;
  }
  function polygonPath(pts){ return pts.map(p=>`${p.x},${p.y}`).join(' '); }

  function updateOppositeAfterDrag(idx){
    if(idx===0){ C={x:B.x+D.x-A.x, y:B.y+D.y-A.y}; }
    else if(idx===1){ D={x:A.x+C.x-B.x, y:A.y+C.y-B.y}; }
    else if(idx===2){ A={x:B.x+D.x-C.x, y:B.y+D.y-C.y}; }
    else if(idx===3){ B={x:A.x+C.x-D.x, y:A.y+C.y-D.y}; }
  }

  function render(){
    if (mode!=='pieces' && colorControls) colorControls.style.display='none';
    layerPoly.innerHTML=''; layerHandles.innerHTML=''; layerCut.innerHTML='';

    if (mode==='pieces' && pieces){
      pieces.forEach((pc, idx)=>{
        const g = mk('g', {class:'grab'});
        const moved = pc.pts.map(p=>({x:p.x+pc.dx, y:p.y+pc.dy}));
        const fillColor = pc.color || (idx? '#fde68a' : '#c7d2fe');
        const poly = mk('polygon', {points: polygonPath(moved), fill: fillColor, stroke:'#0f172a', 'stroke-width':2, opacity:0.9});
        g.appendChild(poly);
        const cx = moved.reduce((s,p)=>s+p.x,0)/moved.length; const cy = moved.reduce((s,p)=>s+p.y,0)/moved.length;
        const handle = mk('circle', {cx, cy, r:7, fill:'#0f172a'}); g.appendChild(handle);
        g.addEventListener('mousedown', startDragPiece(idx)); g.addEventListener('touchstart', startDragPiece(idx), {passive:false});
        layerPoly.appendChild(g);
      });
      if (colorControls) {
        colorControls.style.display='grid';
        if (!pieces[0].color) pieces[0].color = '#c7d2fe';
        if (!pieces[1].color) pieces[1].color = '#fde68a';
        if (color1El) { color1El.value = pieces[0].color; color1El.oninput = e=>{ pieces[0].color = e.target.value; render(); }; }
        if (color2El) { color2El.value = pieces[1].color; color2El.oninput = e=>{ pieces[1].color = e.target.value; render(); }; }
      }
      const tip = mk('text', {x:16,y:24,fill:'#334155','font-size':14}); tip.textContent='조각을 드래그해서 서로 반대 방향으로 붙여 보세요 (직선 180° + 180°).'; layerPoly.appendChild(tip);
      return;
    }

    const pts=[A,B,C,D];
    layerPoly.appendChild(mk('polygon', {points: polygonPath(pts), fill:'#e2e8f0', stroke:'#0f172a', 'stroke-width':2}));
    layerPoly.appendChild(mk('polyline', {points: polygonPath([...pts,A]), fill:'none', stroke:'#0f172a', 'stroke-width':2}));

    for(let i=0;i<4;i++) drawAngleArc(pts,i,28,['#60a5fa','#f472b6','#34d399','#fbbf24'][i]);

    const names=['A','B','C','D']; const angles=pts.map((_,i)=>angleAt(pts,i)); const sum=angles.reduce((a,b)=>a+b,0);
    for(let i=0;i<4;i++){
      const p=pts[i]; const dot=mk('circle',{cx:p.x,cy:p.y,r:7,fill:'#0f172a',class:'handle'});
      dot.addEventListener('mousedown',startDragVertex(i)); dot.addEventListener('touchstart',startDragVertex(i),{passive:false}); layerHandles.appendChild(dot);
      const label=mk('text',{x:p.x+10,y:p.y-10,fill:'#0f172a','font-size':12,'font-weight':600}); label.textContent=names[i]; layerHandles.appendChild(label);
      const prev=pts[(i+3)%4], next=pts[(i+1)%4]; const v1=norm({x:prev.x-p.x,y:prev.y-p.y}), v2=norm({x:next.x-p.x,y:next.y-p.y});
      const bis=norm({x:v1.x+v2.x,y:v1.y+v2.y}); const tx=p.x+bis.x*24, ty=p.y+bis.y*24;
      const txt=mk('text',{x:tx,y:ty,fill:'#0f172a','font-size':12,'text-anchor':'middle'}); txt.textContent=`${angles[i].toFixed(1)}°`; layerHandles.appendChild(txt);
    }

    legend.innerHTML=''; ['∠A','∠B','∠C','∠D'].forEach((nm,i)=>{ const pill=document.createElement('div'); pill.className='pill'; const l=document.createElement('span'); l.textContent=nm; const r=document.createElement('span'); r.style.fontWeight='600'; r.style.color=['#60a5fa','#f472b6','#34d399','#fbbf24'][i]; r.textContent=angleAt(pts,i).toFixed(1)+'°'; pill.appendChild(l); pill.appendChild(r); legend.appendChild(pill); });
    sumEl.textContent = sum.toFixed(1)+'°';

    if (mode==='cut'){
      const tip=mk('text',{x:16,y:24,fill:'#334155','font-size':14}); tip.textContent='드래그하여 자를 선분을 그리세요 (다 그리면 마우스 놓기)'; layerCut.appendChild(tip);
    }
  }

  function drawAngleArc(pts,i,r,color){
    const P=pts[i], prev=pts[(i+3)%4], next=pts[(i+1)%4];
    const a1=Math.atan2(prev.y-P.y, prev.x-P.x), a2=Math.atan2(next.y-P.y, next.x-P.x);
    let start=a1, end=a2; let diff=((end-start)%(2*Math.PI)+2*Math.PI)%(2*Math.PI);
    if(diff>Math.PI){ [start,end]=[end,start]; diff=2*Math.PI-diff; }
    const p1={x:P.x+r*Math.cos(start), y:P.y+r*Math.sin(start)}; const p2={x:P.x+r*Math.cos(end), y:P.y+r*Math.sin(end)};
    const large=diff>Math.PI?1:0; const d=`M ${P.x} ${P.y} L ${p1.x} ${p1.y} A ${r} ${r} 0 ${large} 1 ${p2.x} ${p2.y} Z`;
    layerPoly.appendChild(mk('path',{d, fill:color, opacity:0.45, stroke:color}));
  }

  // dragging vertices
  let dragV=null;
  function startDragVertex(idx){ return (e)=>{ e.preventDefault(); const pt=clientToSVG(e); dragV={idx,last:pt}; window.addEventListener('mousemove',onDragVertex); window.addEventListener('mouseup',endDragVertex); window.addEventListener('touchmove',onDragVertex,{passive:false}); window.addEventListener('touchend',endDragVertex); }; }
  function onDragVertex(e){ if(!dragV||mode!=='shape') return; e.preventDefault(); const pt=clientToSVG(e); const dx=pt.x-dragV.last.x, dy=pt.y-dragV.last.y; const idx=dragV.idx; if(idx===0) A={x:A.x+dx,y:A.y+dy}; if(idx===1) B={x:B.x+dx,y:B.y+dy}; if(idx===2) C={x:C.x+dx,y:C.y+dy}; if(idx===3) D={x:D.x+dx,y:D.y+dy}; updateOppositeAfterDrag(idx); dragV.last=pt; render(); }
  function endDragVertex(){ dragV=null; window.removeEventListener('mousemove',onDragVertex); window.removeEventListener('mouseup',endDragVertex); window.removeEventListener('touchmove',onDragVertex); window.removeEventListener('touchend',endDragVertex); }

  // cutting
  let cutting=null;
  btnCut.addEventListener('click', ()=>{ if(mode==='shape'){ mode='cut'; btnCut.classList.add('active'); svg.classList.add('mode-cut'); } else if(mode==='cut'){ mode='shape'; btnCut.classList.remove('active'); svg.classList.remove('mode-cut'); } render(); });
  btnReset.addEventListener('click', ()=>{ mode='shape'; btnCut.classList.remove('active'); svg.classList.remove('mode-cut'); pieces=null; A={x:220,y:200}; B={x:420,y:180}; C={x:560,y:320}; D={x:360,y:340}; render(); });

  svg.addEventListener('mousedown', (e)=>{ if(mode!=='cut') return; cutting={ start: clientToSVG(e), end: null }; render(); });
  svg.addEventListener('mousemove', (e)=>{ if(mode!=='cut'||!cutting) return; cutting.end = clientToSVG(e); drawCutOverlay(); });
  svg.addEventListener('mouseup',   (e)=>{ if(mode!=='cut'||!cutting) return; cutting.end = clientToSVG(e); trySplitAlongSegment(cutting.start, cutting.end); cutting=null; });

  function drawCutOverlay(){ if(!cutting) return; layerCut.innerHTML=''; const {start,end}=cutting; const line=mk('line',{x1:start.x,y1:start.y,x2:end.x,y2:end.y,stroke:'var(--cut)','stroke-width':3,'stroke-dasharray':'8 6'}); layerCut.appendChild(line); }

  function segIntersect(p1,p2,q1,q2){ const r={x:p2.x-p1.x,y:p2.y-p1.y}; const s={x:q2.x-q1.x,y:q2.y-q1.y}; const rxs=r.x*s.y-r.y*s.x; const qp={x:q1.x-p1.x,y:q1.y-p1.y}; if(Math.abs(rxs)<1e-9) return null; const t=(qp.x*s.y-qp.y*s.x)/rxs; const u=(qp.x*r.y-qp.y*r.x)/rxs; if(t>=0&&t<=1&&u>=0&&u<=1) return {t,u,point:{x:p1.x+t*r.x,y:p1.y+t*r.y}}; return null; }

  function trySplitAlongSegment(S,E){
    const poly=[A,B,C,D]; const edges=[[A,B],[B,C],[C,D],[D,A]]; const hits=[];
    edges.forEach((ed,i)=>{ const I=segIntersect(ed[0],ed[1],S,E); if(I) hits.push({i, point:I.point, tEdge:I.t}); });
    if(hits.length!==2){ layerCut.innerHTML=''; const warn=mk('text',{x:16,y:24,fill:'#b91c1c','font-size':14}); warn.textContent='자르는 선분이 도형의 변과 두 번 교차해야 합니다. 다시 시도해 보세요.'; layerCut.appendChild(warn); render(); return; }
    hits.sort((a,b)=> a.i===b.i ? a.tEdge-b.tEdge : a.i-b.i); const h1=hits[0], h2=hits[1];
    function insertAt(poly){ let pts=[]; for(let i=0;i<4;i++){ const p=poly[i], q=poly[(i+1)%4]; pts.push({...p}); const match=[h1,h2].filter(h=>h.i===i).sort((a,b)=>a.tEdge-b.tEdge); match.forEach(h=>pts.push({...h.point})); } return pts; }
    const pts6=insertAt(poly);
    function findIndexOfPoint(arr,P){ for(let i=0;i<arr.length;i++) if(dist(arr[i],P)<1e-6) return i; return -1; }
    const i1=findIndexOfPoint(pts6,h1.point), i2=findIndexOfPoint(pts6,h2.point);
    function range(a,b){ const out=[]; for(let k=a; k!==b; k=(k+1)%pts6.length) out.push(pts6[k]); out.push(pts6[b]); return out; }
    const path1=range(i1,i2), path2=range(i2,i1);
    const piece1=[...path1, {...h1.point}], piece2=[...path2, {...h2.point}];
    pieces=[ {pts: dedupeClose(piece1), dx:0, dy:0, color:'#c7d2fe'}, {pts: dedupeClose(piece2), dx:0, dy:0, color:'#fde68a'} ];
    mode='pieces'; btnCut.classList.remove('active'); svg.classList.remove('mode-cut'); render();
  }

  function dedupeClose(arr){ const out=[]; for(const p of arr){ if(!out.length||dist(out[out.length-1],p)>1e-6) out.push(p); } if(out.length&&dist(out[0],out[out.length-1])<1e-6) out.pop(); return out; }

  // drag pieces
  let dragP=null; function startDragPiece(idx){ return (e)=>{ e.preventDefault(); const pt=clientToSVG(e); dragP={idx,last:pt}; window.addEventListener('mousemove',onDragPiece); window.addEventListener('mouseup',endDragPiece); window.addEventListener('touchmove',onDragPiece,{passive:false}); window.addEventListener('touchend',endDragPiece); document.body.classList.add('grabbing'); }; }
  function onDragPiece(e){ if(!dragP||mode!=='pieces') return; e.preventDefault(); const pt=clientToSVG(e); const dx=pt.x-dragP.last.x, dy=pt.y-dragP.last.y; pieces[dragP.idx].dx+=dx; pieces[dragP.idx].dy+=dy; dragP.last=pt; render(); }
  function endDragPiece(){ dragP=null; document.body.classList.remove('grabbing'); window.removeEventListener('mousemove',onDragPiece); window.removeEventListener('mouseup',endDragPiece); window.removeEventListener('touchmove',onDragPiece); window.removeEventListener('touchend',endDragPiece); }

  function clientToSVG(e){ const pt=svg.createSVGPoint(); const src=e.touches&&e.touches[0]?e.touches[0]:e; pt.x=src.clientX; pt.y=src.clientY; const sp=pt.matrixTransform(svg.getScreenCTM().inverse()); return {x:sp.x,y:sp.y}; }

  render();
})();
</script>
</body>
</html>
